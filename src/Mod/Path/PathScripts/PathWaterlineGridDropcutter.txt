Grid Dropcutter

The idea of algorithm was inspired by OCL Dropcutter but the code was totally redesigned. Now OCL library is not required. It was found, thap the previous algorithm is very slow for models with several thousand faces. Generally it was caused by ineffective area.makeSections routine. This routine actually was used for estimation of bound boxes only. In the new version bound boxex are calculated directly from tessellation of faces.

New features:
The processing can be made inside the contour specified by selected faces.
Variables BoundaryAdjustment and BoundaryEnforcement can be used.
Any tool including ball end tools can be used. Paths for a ball end tools are calculated with performance comparable with endmill ones. Old tool format is not supported.
In multi-layer mode the processing of whole required area on each level is performed with the specified StepOver value.
Finishing can be selected. In this case finishing passes are executed after full draft processing in upwards direction which can minimize the affect of shavings, if they are not removed fast enough. The distance between finishing layers is specified by FinishDepth parameter.
In transitions between layer the appropriate ramps are inserted. The transitions between paths are optimized and are executed without steps over if possible. 

Selection of the area.
If no faces are specified all models included in the job are processed. The processing area can be limited by Stock using BoundBox parameter.
Any number of faces can be specified. The tail of this list can be treated as "Void", that is marked for exclusion using the parameter named AvoidLastXFaces.
If at least one included face exist, the processing is done inside the projection of this face to XY plane, even if the face is not visible from positive Z direction. You can use this feature to specify processing areas of one model with selection of faces of an auxiliary model located under the processed one.
If several faces are selected the common projection to XY plane is processed. One can choose how to process this features - collectively or individually. The area can be contracted or expanded with positive or negative values of BoundaryAdjustment respectively. The area determines the place where the center of a tool can be located. Therefore if you want to process a face with some small adjoining features it is sufficient to select the central face and set the appropriate negative value for BoundaryAdjustment.
Normally the projection of excluded features is removed from this after boundary adjustment. Therefore a side of the mill can pass over excluded features. If parameter BoundaryEnforcement is true the whole mill is always outside the excluded faces. To force the mill to be inside the boundaries of the included faces one can specify BoundaryAdjustment equal to mill radius.

The principle and the structure of the algorithm.

For each model group a level map is created. The level map is a structure having a rectangular array of elevations in Z direction plus several fields, which describe the position and resolution of the map. The array is implemented as a numpy array of floats now. Each cell of the array contains the exact value of the maximum elevation of some surface in the square given by XY coordinates in min_x + i * sample_interval .. min_x + (i + 1) * sample_interval, min_y + j * sample_interval .. min_y + (j + 1) * sample_interval where i and j are indices of the cell. Initially a surface which covers all set of models is created. For the calculation of this surface the facet is tessellated and for each triangle each crossection of the edge projection to XY plane with the grid and each cell wholly located inside the triangle are calculated.

Then it is transformed in place to the minimal surface where the tip of tool can be located without cutting of extra material from the desired part. To create this surface first the profile of the tool is gathered from the tool 3D model using the same procedure. Then the list named "job" is created. Items of this list describe the shift in i, j and z direction of the resulting map and the original map when the operation of cell by cell maximum between them is performed. Roughly speaking we should made this operation for each cell of the tool footprint. But several optimization tricks can significantly reduce this job. First partial maximums of cells can be calculated for horizontal areas of the tool profile. Then the original map is previously analyzed row by row, and for each row maximal and minimal derivatives along both coordinates are stored. Using this derivatives it is possible quickly estimate which parts of the tool profile can't be in contact with the surface anywhere in this row and exclude them from calculation. Also the calculations is optimized with the aim to keep data in L0 and L1 caches of processor as effective as it is possible.


