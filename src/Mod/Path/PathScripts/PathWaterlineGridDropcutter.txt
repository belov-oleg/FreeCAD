Grid Dropcutter

The idea of algorithm was inspired by OCL Dropcutter but the code was totally redesigned. Now OCL library is not required. It was found, thap the previous algorithm is very slow for models with several thousand faces. Generally it was caused by ineffective area.makeSections routine. This routine actually was used for estimation of bound boxes only. In the new version bound boxex are calculated directly from tessellation of faces.

New features:
The processing can be made inside the contour specified by selected faces.
Variables BoundaryAdjustment and BoundaryEnforcement can be used.
Any tool including ball end tools can be used. Paths for a ball end tools are calculated with performance comparable with endmill ones. Old tool format is not supported.
In multi-layer mode the processing of whole required area on each level is performed with the specified StepOver value.
Finishing can be selected. In this case finishing passes are executed after full draft processing in upwards direction which can minimize the affect of shavings, if they are not removed fast enough. The distance between finishing layers is specified by FinishDepth parameter.
In transitions between layer the appropriate ramps are inserted. The transitions between paths are optimized and are executed without steps over if possible. 

Selection of the area.
If no faces are specified (or all specified faces are declared as Void or Excluded using AvoidLastXFaces parameter), all models included in the job are processed. The processing area is calculated as a contour of the model part, located above the FinalDepth level, expanded to the tool radius. BoundaryAdjustment can be used to expand (negative value) or contract this area.
Also the area is limited by Stock or BoundBox of the Model using BoundBox parameter.
Each model, located not below the FinalDepth level is profiled separately. If any other model is located in this area it is taken into account, but not profiled. The minimal gap between this model and the mill will be not less then ExtraOffset.

Any number of faces can be specified. The tail of this list can be treated as "Void", that is marked for exclusion using the parameter named AvoidLastXFaces.
If at least one included face exist, the processing is done inside the projection of this face to XY plane, even if the face is not visible from positive Z direction. You can use this feature to specify processing areas of one model with selection of faces of an auxiliary model located under the processed one.
If several faces are selected the common projection to XY plane is processed. One can choose how to process this features - collectively or individually. Different models are always processed individually. The area can be contracted or expanded with positive or negative values of BoundaryAdjustment respectively. The area determines the place where the center of a tool can be located. Therefore if you want to process a face with some small adjoining features it is sufficient to select the central face and set the appropriate negative value for BoundaryAdjustment.

There are several possible combinations of BoundaryAdjustment and BoundaryEnforcement.

1 BoundaryEnforcement=False. Excluded faces are removed before boundary adjustment. BoundaryAdjustment is calculated using fast and not exact algorithm.

2 BoundaryEnforcement=True, BoundaryAdjustment > radius of the mill. Excluded faces are removed before boundary adjustment. BoundaryAdjustment is calculated using exact algorithm. Note that the gap between the processed model and the other models is calculated approximately.

3 BoundaryEnforcement=True, BoundaryAdjustment < radius of the mill, but is not negative. Excluded faces are removed before boundary adjustment. BoundaryAdjustment is calculated using exact algorithm and is equal to the radius of the mill. The gap between the processed model and the other models is calculated approximately.

4 BoundaryEnforcement=True, BoundaryAdjustment is negative. On the one hand we want to expand the area, but on the other hand we are specifying the boundary enforcement.
In this case the boundary will be shifted away using the not exact algorithm, and then the boundary of excluded faces, shifted away with the exact algorithm to the radius of the mill will be excluded from the area.

The principle and the structure of the algorithm.

For each model group a level map is created. The level map is a structure having a rectangular array of elevations in Z direction plus several fields, which describe the position and resolution of the map. The array is implemented as a numpy array of floats now. Each cell of the array contains the exact value of the maximum elevation of some surface in the square given by XY coordinates in min_x + i * sample_interval .. min_x + (i + 1) * sample_interval, min_y + j * sample_interval .. min_y + (j + 1) * sample_interval where i and j are indices of the cell. Initially a surface which covers all set of models is created. For the calculation of this surface the facet is tessellated and for each triangle each intersection of the edge projection to XY plane with the grid and each cell wholly located inside the triangle are calculated.

Then it is transformed in place to the minimal surface where the tip of tool can be located without cutting of extra material from the desired part. To create this surface first the profile of the tool is gathered from the tool 3D model using the same procedure. Then the list named "job" is created. Items of this list describe the shift in i, j and z direction of the resulting map and the original map when the operation of cell by cell maximum between them is performed. Roughly speaking we should made this operation for each cell of the tool footprint. But several optimization tricks can significantly reduce this job. First partial maximums of cells can be calculated for horizontal areas of the tool profile. Then the original map is previously analyzed row by row, and for each row maximal and minimal derivatives along both coordinates are stored. Using this derivatives it is possible to quickly estimate which parts of the tool profile can't be in contact with the surface anywhere in this row and exclude them from calculation. Also the calculations is optimized with the aim to keep data in L1 and L2 caches of processor as effective as it is possible.

For calculation of the path this surface is crossed by the plane at the appropriate level and a contour map is created. Each cell of the contour map contains one of 4 values: 0 - air, 1 - gray zone, 2 - expanded material and 4 - material. Initially this map contains only air and material, then the bound of material is marked as a gray zone. The center of tool can pass anywhere inside this zone. The algorithm selects points when the cells of gray zone are connected by corners, but not by edges. These points form the path. Also a special processing of the turns on 90 degrees and a back tracing of narrow gaps are performed. For multi-layer processing the bound of the material is expanded away on the specified distance and a new gray zone is selected.

For optimization of the tool movement adjacent paths are joined together where it is possible with a straight line without touching the material, that is only over cells marked as 0 or 2 on the contour map. After this optimization an appropriate ramps are inserted.

The finishing is performed similarly, but also the calculated paths can be slightly shifted down for better processing of shelves and gently sloping surfaces. The distance between paths is calculated in accordance with the tool profile and the sample interval.
